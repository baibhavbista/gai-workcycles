import { app, screen, BrowserWindow, Tray, Menu, globalShortcut, nativeImage, ipcMain, safeStorage, session } from 'electron';
import path from 'node:path';
import {
  insertSession,
  insertCycle,
  finishCycle,
  getSessionById,
  SessionPayload,
  CycleStartPayload,
  CycleFinishPayload,
  listSessionsWithCycles,
  saveWindowBounds,
  getWindowBounds,
  WindowBounds,
  getSettings,
  saveSettings,
  saveEncryptedKey,
  getEncryptedKey,
  saveSessionReview,
  saveCycleNote,
  getCycleNotes,
  getSessionNotes,
  deleteCycleNote,
  updateCycleNote,
  CycleNotePayload,
} from './db.ts';
import { embeddingManager } from './embedding-manager.ts';
import { conversationalAgent } from './conversational-agent.ts';
import { 
  searchEmbeddings, 
  cascadingSearch
} from './db.ts';

// NOTE: This is an early scaffold. Additional tray, global shortcuts, IPC, and
// database logic will be added in subsequent phases.

let win: BrowserWindow | null = null;
let tray: Tray | null = null;
let currentHotkey: string | null = null;

const ICON_PATH = path.join(__dirname, 'assets', 'icons', 'png', '256x256.png');

function createWindow() {
  win = new BrowserWindow({
    width: 480,
    height: 950,
    show: false,
    frame: true,
    roundedCorners: true,
    resizable: true,
    icon: ICON_PATH,
    webPreferences: {
      preload: path.join(__dirname, 'preload.cjs'),
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  // Set up permission handler for media access
  win.webContents.session.setPermissionRequestHandler((webContents, permission, callback) => {
    const allowedPermissions = ['media'];
    if (allowedPermissions.includes(permission)) {
      callback(true);
    } else {
      callback(false);
    }
  });

  const isDev = process.env.NODE_ENV === 'dev';

  if (isDev) {
    // During dev we load the Vite dev server. Make sure the port matches the
    // one used in package.json scripts (5173 by default).
    win.loadURL('http://localhost:5173');
    win.webContents.openDevTools({ mode: 'detach' });
  } else {
    // In production, load the packaged index.html generated by Vite.
    win.loadFile(path.join(__dirname, '../dist/index.html'));
  }

  // Once the contents are ready, position the window on the current Space
  // using our helper that remembers bounds and brings it to the foreground.
  win.once('ready-to-show', () => {
    if (win) {
      showOnCurrentSpace(win);
    }
  });

  // Save bounds whenever moved or resized
  const saveBounds = () => {
    if (!win) return;
    const cursor = screen.getCursorScreenPoint();
    const disp = screen.getDisplayNearestPoint(cursor);
    saveWindowBounds(String(disp.id), win.getBounds());
  };
  win.on('move', saveBounds);
  win.on('resize', saveBounds);

  win.on('closed', () => {
    win = null;
  });
}

function showWindowRememberingBounds(win: BrowserWindow) {
  const cursorPoint = screen.getCursorScreenPoint();
  const display = screen.getDisplayNearestPoint(cursorPoint);

  const saved: WindowBounds | undefined = getWindowBounds(String(display.id));

  if (saved) {
    win.setBounds(saved);
  } else {
    // the default position where we want to show the window
    const { x, y, width, height } = display.workArea; // use workArea to avoid macOS menu bar etc.

    const winBounds = win.getBounds();

    // slightly to the right
    const targetX = x + Math.round(Math.min((width * 0.6), ((width * 0.9) - winBounds.width)));
    // centered on top
    const targetY = y + Math.round((height - winBounds.height) / 2);

    win.setBounds({ x: targetX, y: targetY, width: winBounds.width, height: winBounds.height });
  }
  win.show();

  // win.focus();
}

function showOnCurrentSpace(win: BrowserWindow) {
  // allow on all Spaces so macOS will instantiate in the active one
  win.setVisibleOnAllWorkspaces(true, { visibleOnFullScreen: false });

  // 2) restore bounds & show
  showWindowRememberingBounds(win);

  // 3) as soon as it's visible, "lock" it back to this Space only
  //    using process.nextTick so it happens after the window actually shows
  process.nextTick(() => {
    win.setVisibleOnAllWorkspaces(false);
    // not sure where to keep win.focus(). Seems to be working?
    win.focus();
  });
}

function toggleWindow() {
  if (!win) return;
  if (win.isVisible()) {
    win.hide();
  } else {
    showOnCurrentSpace(win);
    // win.focus();
  }
}


function createTray() {
  let iconImage = nativeImage.createEmpty();
  try {
    const loaded = nativeImage.createFromPath(ICON_PATH);
    if (!loaded.isEmpty()) {
      if (process.platform === 'darwin') {
        iconImage = loaded.resize({ width: 16, height: 16 });
        iconImage.setTemplateImage(true);
      } else {
        iconImage = loaded.resize({ width: 24, height: 24 });
      }
    }
  } catch {
    // ignore, fallback to empty image
  }

  tray = new Tray(iconImage);
  const contextMenu = Menu.buildFromTemplate([
    { label: 'Open WorkCycles', click: () => toggleWindow() },
    { type: 'separator' },
    { label: 'Quit', click: () => app.quit() },
  ]);
  tray.setToolTip('WorkCycles');
  tray.setContextMenu(contextMenu);

  // On click, toggle visibility
  // tray.on('click', () => toggleWindow());
}

function registerGlobalHotkey(accelerator: string) {
  // Unregister previous if exists
  if (currentHotkey) {
    globalShortcut.unregister(currentHotkey);
  }
  const ok = globalShortcut.register(accelerator, () => {
    toggleWindow();
  });
  if (!ok) {
    console.warn(`Global shortcut registration failed for ${accelerator}`);
  } else {
    currentHotkey = accelerator;
  }
  return ok;
}

app.whenReady().then(async () => {
  // Initialize the embedding system
  try {
    console.log('Starting WorkCycles embedding system...');
    
    // Start the background embedding processor
    embeddingManager.startProcessing();
    
    // Check if we should backfill existing data when AI is first enabled
    const settings = getSettings();
    if (settings.aiEnabled) {
      console.log('AI enabled - checking for existing data to process...');
      setTimeout(async () => {
        try {
          await embeddingManager.backfillExistingData(50);
        } catch (error) {
          console.error('Startup backfill failed:', error);
        }
      }, 5000); // Wait 5 seconds after app start
    }
    
    console.log('Embedding system initialized successfully');
  } catch (error) {
    console.error('Failed to initialize embedding system:', error);
  }
  
  createWindow();
  
  // disabling tray for MVP
  //   known issues: icon is weird; maybe should enable only on macos; keeps the timer going even after cycle closed/back
  // createTray();

  // Load user settings to register hotkey
  const settings = getSettings();
  registerGlobalHotkey(settings.hotkey);

  // Set dock icon on macOS during dev
  if (process.platform === 'darwin') {
    try {
      app.dock.setIcon(ICON_PATH);
    } catch {}
  }
});

// On macOS, recreate window when dock icon is clicked and there are no other
// windows open.
app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// Quit the app when all windows are closed (except on macOS where apps
// generally stay open until the user explicitly quits).
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('will-quit', () => {
  // Unregister all shortcuts.
  globalShortcut.unregisterAll();
  
  // Gracefully shutdown the embedding system
  try {
    console.log('Shutting down embedding system...');
    embeddingManager.shutdown();
    console.log('Embedding system shutdown complete');
  } catch (error) {
    console.error('Error during embedding system shutdown:', error);
  }
});

// ---------- IPC handlers ----------

ipcMain.handle('wc:session-create', (_, payload: SessionPayload) => {
  return insertSession(payload);
});

ipcMain.handle('wc:cycle-start', async (_, payload: CycleStartPayload) => {
  const id = insertCycle(payload);
  // Note: Embedding jobs are now automatically created by the insertCycle function
  // in db.ts as part of the integrated job queue system
  return id;
});

ipcMain.handle('wc:cycle-finish', (_, payload: CycleFinishPayload) => {
  finishCycle(payload);
  return { ok: true };
});

ipcMain.handle('wc:get-session', (_, sessionId: string) => {
  return getSessionById(sessionId);
});

ipcMain.handle('wc:vector-search', async (_, query: string, k = 8) => {
  try {
    // Use cascading search which intelligently searches across all levels
    const results = await cascadingSearch(query, query, k);
    return results;
  } catch (error) {
    console.error('Vector search failed:', error);
    return [];
  }
});

ipcMain.handle('wc:list-sessions', () => {
  return listSessionsWithCycles();
});

// -------- Settings IPC --------

ipcMain.handle('wc:get-settings', () => {
  return getSettings();
});

// Note: wc:save-settings handler moved to the embedding section below for enhanced functionality

ipcMain.handle('wc:save-openai-key', (_e, plainKey: string) => {
  if (!plainKey) {
    saveEncryptedKey(null, 0);
    // Reset embedding client when key is removed
    embeddingManager.resetClient();
    return { ok: true };
  }

  try {
    if (safeStorage.isEncryptionAvailable()) {
      const cipher = safeStorage.encryptString(plainKey);
      saveEncryptedKey(cipher, 1);
    } else {
      console.warn('safeStorage encryption not available, storing key in plain text');
      saveEncryptedKey(Buffer.from(plainKey, 'utf-8'), 0);
    }
    
    // Reset embedding client to use the new key
    embeddingManager.resetClient();
    
  } catch (err) {
    console.error('Failed to encrypt/store OpenAI key', err);
    throw err;
  }
  return { ok: true };
});

ipcMain.handle('wc:get-openai-key', () => {
  const row = getEncryptedKey();
  if (!row) return null;
  const { cipher, encrypted } = row;

  if (encrypted) {
    if (safeStorage.isEncryptionAvailable()) {
      try {
        return safeStorage.decryptString(Buffer.from(cipher));
      } catch {
        return null;
      }
    }
    // Cannot decrypt on this platform/session
    return null;
  }
  // plain text
  return cipher.toString();
});

ipcMain.handle('wc:is-encryption-available', () => {
  return safeStorage.isEncryptionAvailable();
});

// ---- Tray title updates ----
ipcMain.handle('wc:update-tray', (_e, title: string) => {
  if (!tray) return { ok: false };
  if (process.platform === 'darwin') {
    tray.setTitle(title || '');
  }
  return { ok: true };
});

ipcMain.handle('wc:session-review-save', (_e, sessionId: string, review) => {
  saveSessionReview(sessionId, review);
  return { ok: true };
});

// -------- Cycle Notes IPC --------

ipcMain.handle('wc:cycle-note-save', (_e, payload: CycleNotePayload) => {
  return saveCycleNote(payload);
});

ipcMain.handle('wc:cycle-notes-get', (_e, sessionId: string, cycleId: string) => {
  return getCycleNotes(sessionId, cycleId);
});

ipcMain.handle('wc:session-notes-get', (_e, sessionId: string) => {
  return getSessionNotes(sessionId);
});

ipcMain.handle('wc:cycle-note-delete', (_e, noteId: string) => {
  deleteCycleNote(noteId);
  return { ok: true };
});

ipcMain.handle('wc:cycle-note-update', (_e, noteId: string, text: string) => {
  updateCycleNote(noteId, text);
  return { ok: true };
});

// -------- Embedding System IPC --------

ipcMain.handle('wc:embedding-status', () => {
  try {
    return embeddingManager.getStatus();
  } catch (error) {
    console.error('Failed to get embedding status:', error);
    return {
      isProcessing: false,
      queueStatus: { pending: 0, processing: 0, total: 0 },
      statistics: { pending: 0, processing: 0, done: 0, error: 0 }
    };
  }
});

ipcMain.handle('wc:embedding-search', async (_, query: string, options = {}) => {
  try {
    return await embeddingManager.search(query, options);
  } catch (error) {
    console.error('Embedding search failed:', error);
    return [];
  }
});

ipcMain.handle('wc:embedding-cascading-search', async (_, query: string, userIntent: string, k = 8) => {
  try {
    return await embeddingManager.cascadingSearch(query, userIntent, k);
  } catch (error) {
    console.error('Cascading search failed:', error);
    return [];
  }
});

// Enhanced search methods
ipcMain.handle('wc:enhanced-search', async (_, query: string, userIntent?: string, options = {}) => {
  try {
    return await embeddingManager.enhancedSearch(query, userIntent, options);
  } catch (error) {
    console.error('Enhanced search failed:', error);
    return [];
  }
});

ipcMain.handle('wc:enhanced-cascading-search', async (_, query: string, userIntent: string, k = 8, options = {}) => {
  try {
    return await embeddingManager.enhancedCascadingSearch(query, userIntent, k, options);
  } catch (error) {
    console.error('Enhanced cascading search failed:', error);
    return [];
  }
});

ipcMain.handle('wc:search-suggestions', async (_, partialQuery: string, limit = 5) => {
  try {
    return await embeddingManager.getSearchSuggestions(partialQuery, limit);
  } catch (error) {
    console.error('Search suggestions failed:', error);
    return [];
  }
});

ipcMain.handle('wc:search-analytics', () => {
  try {
    return embeddingManager.getSearchAnalytics();
  } catch (error) {
    console.error('Search analytics failed:', error);
    return {
      totalSearches: 0,
      recentSearches: 0,
      avgResultsPerSearch: 0,
      commonQueries: [],
      searchTrends: []
    };
  }
});

ipcMain.handle('wc:embedding-backfill', async (_, limit = 100) => {
  try {
    console.log('Manual embedding backfill requested');
    return await embeddingManager.backfillExistingData(limit);
  } catch (error) {
    console.error('Embedding backfill failed:', error);
    return { sessionsProcessed: 0, cyclesProcessed: 0, jobsCreated: 0 };
  }
});

// Handle settings changes that affect embeddings
ipcMain.handle('wc:save-settings', async (_e, patch: Partial<ReturnType<typeof getSettings>>) => {
  const previousSettings = getSettings();
  saveSettings(patch);

  // Hotkey update if changed
  if (patch.hotkey && patch.hotkey !== currentHotkey) {
    registerGlobalHotkey(patch.hotkey);
  }
  
  // If AI was just enabled, trigger backfill
  if (patch.aiEnabled && !previousSettings.aiEnabled) {
    console.log('AI just enabled - triggering backfill of existing data');
    setTimeout(async () => {
      try {
        await embeddingManager.backfillExistingData(50);
      } catch (error) {
        console.error('Backfill failed:', error);
      }
    }, 1000);
  }
  
  // If OpenAI settings changed, reset the client
  if (patch.aiEnabled !== undefined) {
    embeddingManager.resetClient();
  }
  
  return { ok: true };
});

// -------- Additional Search & Status IPC --------

ipcMain.handle('wc:list-all-cycles', () => {
  try {
    // Get all cycles from completed sessions
    const sessions = listSessionsWithCycles();
    const allCycles: any[] = [];
    
    for (const session of sessions) {
      for (const cycle of session.cycles) {
        // Only include completed cycles
        if (cycle.status === 'hit' || cycle.status === 'miss') {
          allCycles.push({
            ...cycle,
            sessionId: session.id,
            sessionObjective: session.intentions?.objective,
            sessionStartedAt: session.startedAt,
          });
        }
      }
    }
    
    // Sort by completion time (newest first)
    return allCycles.sort((a, b) => {
      const dateA = new Date(a.endedAt || a.startedAt || 0);
      const dateB = new Date(b.endedAt || b.startedAt || 0);
      
      // TODO: figure out why this happens - why can cycles sometimes have these different kinds of dates
      // Handle invalid dates
      if (isNaN(dateA.getTime()) && isNaN(dateB.getTime())) return 0;
      if (isNaN(dateA.getTime())) return 1;
      if (isNaN(dateB.getTime())) return -1;
      
      return dateB.getTime() - dateA.getTime();
    });
  } catch (error) {
    console.error('Failed to list all cycles:', error);
    return [];
  }
});

ipcMain.handle('wc:get-search-suggestions', async (_, query: string) => {
  try {
    return await embeddingManager.getSearchSuggestions(query, 5);
  } catch (error) {
    console.error('Search suggestions failed:', error);
    return [];
  }
});

ipcMain.handle('wc:embedding-queue-status', () => {
  try {
    // Get queue status from the embedding manager's status method
    const status = embeddingManager.getStatus();
    return {
      ...status.queueStatus,
      statistics: status.statistics
    };
  } catch (error) {
    console.error('Failed to get queue status:', error);
    return {
      pending: 0,
      processing: 0,
      total: 0,
      statistics: { pending: 0, processing: 0, done: 0, error: 0 }
    };
  }
});

ipcMain.handle('wc:embedding-db-stats', () => {
  try {
    // Return basic stats - could be enhanced with more detailed stats later
    const status = embeddingManager.getStatus();
    return {
      totalEmbeddings: status.statistics.done,
      fieldEmbeddings: 0, // Would need to query database for breakdown
      cycleEmbeddings: 0,
      sessionEmbeddings: 0,
      lastUpdate: new Date(),
      storageSize: 0, // Would need to query LanceDB for size
      queueStatistics: status.statistics
    };
  } catch (error) {
    console.error('Failed to get database stats:', error);
    return {
      totalEmbeddings: 0,
      fieldEmbeddings: 0,
      cycleEmbeddings: 0,
      sessionEmbeddings: 0,
      lastUpdate: null,
      storageSize: 0,
      queueStatistics: { pending: 0, processing: 0, done: 0, error: 0 }
    };
  }
});

ipcMain.handle('wc:trigger-embedding-backfill', async (_, limit = 100) => {
  try {
    console.log('Manual embedding backfill requested');
    return await embeddingManager.backfillExistingData(limit);
  } catch (error) {
    console.error('Embedding backfill failed:', error);
    return { sessionsProcessed: 0, cyclesProcessed: 0, jobsCreated: 0 };
  }
});

ipcMain.handle('wc:clear-embedding-cache', () => {
  try {
    // This would clear any in-memory caches
    // For now, just reset the client which will reinitialize connections
    embeddingManager.resetClient();
    return { ok: true };
  } catch (error) {
    console.error('Failed to clear embedding cache:', error);
    return { ok: false };
  }
});

// --- Conversational Agent (Placeholder) ---
ipcMain.handle('agent:sendMessage', async (_event, messages) => {
  console.log('Agent received messages:', messages);
  // This will later invoke the LangGraph agent.
  const response = await conversationalAgent.invoke({ messages });
  win?.webContents.send('agent:onResponse', {
    type: 'text',
    content: response.messages[response.messages.length - 1].content,
  });
});