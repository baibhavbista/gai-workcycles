import { app, screen, BrowserWindow, Tray, Menu, globalShortcut, nativeImage, ipcMain, safeStorage } from 'electron';
import path from 'node:path';
import {
  insertSession,
  insertCycle,
  finishCycle,
  getSessionById,
  SessionPayload,
  CycleStartPayload,
  CycleFinishPayload,
  listSessionsWithCycles,
  saveWindowBounds,
  getWindowBounds,
  WindowBounds,
  getSettings,
  saveSettings,
  saveEncryptedKey,
  getEncryptedKey,
  saveSessionReview,
} from './db';
import { setupVectorTable, indexCycleEmbedding, searchSimilar } from './vector';

// NOTE: This is an early scaffold. Additional tray, global shortcuts, IPC, and
// database logic will be added in subsequent phases.

let win: BrowserWindow | null = null;
let tray: Tray | null = null;
let currentHotkey: string | null = null;

const ICON_PATH = path.join(__dirname, 'assets', 'icons', 'png', '256x256.png');

function createWindow() {
  win = new BrowserWindow({
    width: 480,
    height: 950,
    show: false,
    frame: true,
    roundedCorners: true,
    resizable: true,
    icon: ICON_PATH,
    webPreferences: {
      preload: path.join(__dirname, 'preload.cjs'),
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  const isDev = process.env.NODE_ENV === 'dev';

  if (isDev) {
    // During dev we load the Vite dev server. Make sure the port matches the
    // one used in package.json scripts (5173 by default).
    win.loadURL('http://localhost:5173');
    win.webContents.openDevTools({ mode: 'detach' });
  } else {
    // In production, load the packaged index.html generated by Vite.
    win.loadFile(path.join(__dirname, '../dist/index.html'));
  }

  // Once the contents are ready, position the window on the current Space
  // using our helper that remembers bounds and brings it to the foreground.
  win.once('ready-to-show', () => {
    if (win) {
      showOnCurrentSpace(win);
    }
  });

  // Save bounds whenever moved or resized
  const saveBounds = () => {
    if (!win) return;
    const cursor = screen.getCursorScreenPoint();
    const disp = screen.getDisplayNearestPoint(cursor);
    saveWindowBounds(String(disp.id), win.getBounds());
  };
  win.on('move', saveBounds);
  win.on('resize', saveBounds);

  win.on('closed', () => {
    win = null;
  });
}

function showWindowRememberingBounds(win: BrowserWindow) {
  const cursorPoint = screen.getCursorScreenPoint();
  const display = screen.getDisplayNearestPoint(cursorPoint);

  const saved: WindowBounds | undefined = getWindowBounds(String(display.id));

  if (saved) {
    win.setBounds(saved);
  } else {
    // the default position where we want to show the window
    const { x, y, width, height } = display.workArea; // use workArea to avoid macOS menu bar etc.

    const winBounds = win.getBounds();

    // slightly to the right
    const targetX = x + Math.round(Math.min((width * 0.6), ((width * 0.9) - winBounds.width)));
    // centered on top
    const targetY = y + Math.round((height - winBounds.height) / 2);

    win.setBounds({ x: targetX, y: targetY, width: winBounds.width, height: winBounds.height });
  }
  win.show();

  // win.focus();
}

function showOnCurrentSpace(win: BrowserWindow) {
  // allow on all Spaces so macOS will instantiate in the active one
  win.setVisibleOnAllWorkspaces(true, { visibleOnFullScreen: false });

  // 2) restore bounds & show
  showWindowRememberingBounds(win);

  // 3) as soon as it's visible, "lock" it back to this Space only
  //    using process.nextTick so it happens after the window actually shows
  process.nextTick(() => {
    win.setVisibleOnAllWorkspaces(false);
    // not sure where to keep win.focus(). Seems to be working?
    win.focus();
  });
}

function toggleWindow() {
  if (!win) return;
  if (win.isVisible()) {
    win.hide();
  } else {
    showOnCurrentSpace(win);
    // win.focus();
  }
}


function createTray() {
  let iconImage = nativeImage.createEmpty();
  try {
    const loaded = nativeImage.createFromPath(ICON_PATH);
    if (!loaded.isEmpty()) {
      if (process.platform === 'darwin') {
        iconImage = loaded.resize({ width: 16, height: 16 });
        iconImage.setTemplateImage(true);
      } else {
        iconImage = loaded.resize({ width: 24, height: 24 });
      }
    }
  } catch {
    // ignore, fallback to empty image
  }

  tray = new Tray(iconImage);
  const contextMenu = Menu.buildFromTemplate([
    { label: 'Open WorkCycles', click: () => toggleWindow() },
    { type: 'separator' },
    { label: 'Quit', click: () => app.quit() },
  ]);
  tray.setToolTip('WorkCycles');
  tray.setContextMenu(contextMenu);

  // On click, toggle visibility
  // tray.on('click', () => toggleWindow());
}

function registerGlobalHotkey(accelerator: string) {
  // Unregister previous if exists
  if (currentHotkey) {
    globalShortcut.unregister(currentHotkey);
  }
  const ok = globalShortcut.register(accelerator, () => {
    toggleWindow();
  });
  if (!ok) {
    console.warn(`Global shortcut registration failed for ${accelerator}`);
  } else {
    currentHotkey = accelerator;
  }
  return ok;
}

app.whenReady().then(async () => {
  await setupVectorTable();
  createWindow();
  createTray();

  // Load user settings to register hotkey
  const settings = getSettings();
  registerGlobalHotkey(settings.hotkey);

  // Set dock icon on macOS during dev
  if (process.platform === 'darwin') {
    try {
      app.dock.setIcon(ICON_PATH);
    } catch {}
  }
});

// On macOS, recreate window when dock icon is clicked and there are no other
// windows open.
app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// Quit the app when all windows are closed (except on macOS where apps
// generally stay open until the user explicitly quits).
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('will-quit', () => {
  // Unregister all shortcuts.
  globalShortcut.unregisterAll();
});

// ---------- IPC handlers ----------

ipcMain.handle('wc:session-create', (_, payload: SessionPayload) => {
  return insertSession(payload);
});

ipcMain.handle('wc:cycle-start', async (_, payload: CycleStartPayload) => {
  const id = insertCycle(payload);
  // Fire and forget embedding indexing
  indexCycleEmbedding({
    cycleId: id,
    text: payload.goal,
    energy: payload.energy,
    morale: payload.morale,
  });
  return id;
});

ipcMain.handle('wc:cycle-finish', (_, payload: CycleFinishPayload) => {
  finishCycle(payload);
  return { ok: true };
});

ipcMain.handle('wc:get-session', (_, sessionId: string) => {
  return getSessionById(sessionId);
});

ipcMain.handle('wc:vector-search', async (_, query: string, k = 5) => {
  return searchSimilar(query, k);
});

ipcMain.handle('wc:list-sessions', () => {
  return listSessionsWithCycles();
});

// -------- Settings IPC --------

ipcMain.handle('wc:get-settings', () => {
  return getSettings();
});

ipcMain.handle('wc:save-settings', (_e, patch: Partial<ReturnType<typeof getSettings>>) => {
  saveSettings(patch);

  // Hotkey update if changed
  if (patch.hotkey && patch.hotkey !== currentHotkey) {
    registerGlobalHotkey(patch.hotkey);
  }
  return { ok: true };
});

ipcMain.handle('wc:save-openai-key', (_e, plainKey: string) => {
  if (!plainKey) {
    saveEncryptedKey(null, 0);
    return { ok: true };
  }

  try {
    if (safeStorage.isEncryptionAvailable()) {
      const cipher = safeStorage.encryptString(plainKey);
      saveEncryptedKey(cipher, 1);
    } else {
      console.warn('safeStorage encryption not available, storing key in plain text');
      saveEncryptedKey(Buffer.from(plainKey, 'utf-8'), 0);
    }
  } catch (err) {
    console.error('Failed to encrypt/store OpenAI key', err);
    throw err;
  }
  return { ok: true };
});

ipcMain.handle('wc:get-openai-key', () => {
  const row = getEncryptedKey();
  if (!row) return null;
  const { cipher, encrypted } = row;

  if (encrypted) {
    if (safeStorage.isEncryptionAvailable()) {
      try {
        return safeStorage.decryptString(Buffer.from(cipher));
      } catch {
        return null;
      }
    }
    // Cannot decrypt on this platform/session
    return null;
  }
  // plain text
  return cipher.toString();
});

ipcMain.handle('wc:is-encryption-available', () => {
  return safeStorage.isEncryptionAvailable();
});

// ---- Tray title updates ----
ipcMain.handle('wc:update-tray', (_e, title: string) => {
  if (!tray) return { ok: false };
  if (process.platform === 'darwin') {
    tray.setTitle(title || '');
  }
  return { ok: true };
});

ipcMain.handle('wc:session-review-save', (_e, sessionId: string, review) => {
  saveSessionReview(sessionId, review);
  return { ok: true };
}); 