import { app, screen, BrowserWindow, Tray, Menu, globalShortcut, nativeImage, ipcMain } from 'electron';
import path from 'node:path';
import {
  insertSession,
  insertCycle,
  finishCycle,
  getSessionById,
  SessionPayload,
  CycleStartPayload,
  CycleFinishPayload,
  listSessionsWithCycles,
} from './db';
import { setupVectorTable, indexCycleEmbedding, searchSimilar } from './vector';

// NOTE: This is an early scaffold. Additional tray, global shortcuts, IPC, and
// database logic will be added in subsequent phases.

let win: BrowserWindow | null = null;
let tray: Tray | null = null;

const ICON_PATH = path.join(__dirname, 'assets', 'iconTemplate.png');

function createWindow() {
  win = new BrowserWindow({
    width: 480,
    height: 950,
    frame: true,
    roundedCorners: true,
    resizable: true,
    webPreferences: {
      preload: path.join(__dirname, 'preload.cjs'),
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  const isDev = process.env.NODE_ENV === 'dev';

  if (isDev) {
    // During dev we load the Vite dev server. Make sure the port matches the
    // one used in package.json scripts (5173 by default).
    win.loadURL('http://localhost:5173');
    win.webContents.openDevTools({ mode: 'detach' });
  } else {
    // In production, load the packaged index.html generated by Vite.
    win.loadFile(path.join(__dirname, '../dist/index.html'));
  }

  win.on('closed', () => {
    win = null;
  });
}

function showWindowRememberingBounds(win: BrowserWindow) {
  const cursorPoint = screen.getCursorScreenPoint();
  const display = screen.getDisplayNearestPoint(cursorPoint);
  const { x, y, width, height } = display.workArea; // use workArea to avoid macOS menu bar etc.

  const winBounds = win.getBounds();

  // slightly to the right
  const targetX = x + Math.round(Math.min((width * 0.6), ((width * 0.9) - winBounds.width)));
  // centered on top
  const targetY = y + Math.round((height - winBounds.height) / 2);

  win.setBounds({ x: targetX, y: targetY, width: winBounds.width, height: winBounds.height });
  win.show();

  // win.focus();
}

function showOnCurrentSpace(win: BrowserWindow) {
  // allow on all Spaces so macOS will instantiate in the active one
  win.setVisibleOnAllWorkspaces(true, { visibleOnFullScreen: false });

  // 2) restore bounds & show
  showWindowRememberingBounds(win);

  // 3) as soon as it’s visible, “lock” it back to this Space only
  //    using process.nextTick so it happens after the window actually shows
  process.nextTick(() => {
    win.setVisibleOnAllWorkspaces(false);
    // not sure where to keep win.focus(). Seems to be working?
    win.focus();
  });
}

function toggleWindow() {
  if (!win) return;
  if (win.isVisible()) {
    win.hide();
  } else {
    showOnCurrentSpace(win);
    // win.focus();
  }
}


function createTray() {
  let iconImage = nativeImage.createEmpty();
  try {
    const loaded = nativeImage.createFromPath(ICON_PATH);
    if (!loaded.isEmpty()) {
      iconImage = loaded;
    }
  } catch {
    // ignore, fallback to empty image
  }

  tray = new Tray(iconImage);
  const contextMenu = Menu.buildFromTemplate([
    { label: 'Open WorkCycles', click: () => toggleWindow() },
    { type: 'separator' },
    { label: 'Quit', click: () => app.quit() },
  ]);
  tray.setToolTip('WorkCycles');
  tray.setContextMenu(contextMenu);

  // On click, toggle visibility
  tray.on('click', () => toggleWindow());
}

app.whenReady().then(async () => {
  await setupVectorTable();
  createWindow();
  createTray();

  // Register global shortcut Ctrl+Shift+U
  const success = globalShortcut.register('Control+Shift+U', () => {
    toggleWindow();
  });

  if (!success) {
    // eslint-disable-next-line no-console
    console.warn('Global shortcut registration failed');
  }
});

// On macOS, recreate window when dock icon is clicked and there are no other
// windows open.
app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// Quit the app when all windows are closed (except on macOS where apps
// generally stay open until the user explicitly quits).
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('will-quit', () => {
  // Unregister all shortcuts.
  globalShortcut.unregisterAll();
});

// ---------- IPC handlers ----------

ipcMain.handle('wc:session-create', (_, payload: SessionPayload) => {
  return insertSession(payload);
});

ipcMain.handle('wc:cycle-start', async (_, payload: CycleStartPayload) => {
  const id = insertCycle(payload);
  // Fire and forget embedding indexing
  indexCycleEmbedding({
    cycleId: id,
    text: payload.goal,
    energy: payload.energy,
    morale: payload.morale,
  });
  return id;
});

ipcMain.handle('wc:cycle-finish', (_, payload: CycleFinishPayload) => {
  finishCycle(payload);
  return { ok: true };
});

ipcMain.handle('wc:get-session', (_, sessionId: string) => {
  return getSessionById(sessionId);
});

ipcMain.handle('wc:vector-search', async (_, query: string, k = 5) => {
  return searchSimilar(query, k);
});

ipcMain.handle('wc:list-sessions', () => {
  return listSessionsWithCycles();
}); 